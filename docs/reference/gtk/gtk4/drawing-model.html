<!--
SPDX-FileCopyrightText: GTK Development Team

SPDX-License-Identifier: LGPL-2.1-or-later
-->

<!DOCTYPE html>
<html lang="en">
<head>
  <title>Gtk &ndash; 4.0: Overview of the drawing model</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <meta charset="utf-8" />

  
  <meta property="og:type" content="website"/>

  
  <meta property="og:image:width" content="256"/>
  <meta property="og:image:height" content="256"/>
  <meta property="og:image:secure_url" content="gtk-logo.svg"/>
  <meta property="og:image:alt" content="Gtk-4.0"/>
  

  
  <meta property="og:title" content="Gtk: Overview of the drawing model"/>
  <meta property="og:description" content="Reference for Gtk-4.0: Overview of the drawing model"/>
  <meta name="twitter:title" content="Gtk: Overview of the drawing model"/>
  <meta name="twitter:description" content="Reference for Gtk-4.0: Overview of the drawing model"/>


  
  <meta name="twitter:card" content="summary"/>

  
  
  
  <link rel="search" type="application/opensearchdescription+xml" title="Gtk" href="opensearch.xml">
  
  

  <link rel="stylesheet" href="style.css" type="text/css" />

  

  
  <script src="urlmap.js"></script>
  
  
  <script src="fzy.js"></script>
  <script src="search.js"></script>
  
  <script src="main.js"></script>
</head>

<body>
  <div id="body-wrapper" tabindex="-1">

    <nav class="sidebar devhelp-hidden">
      
      <div class="section">
        <img src="gtk-logo.svg" class="logo"/>
      </div>
      
      
      <div class="search section">
        <form id="search-form" autocomplete="off">
          <input id="search-input" type="text" name="do-not-autocomplete" placeholder="Click, or press 's' to search" autocomplete="off"/>
        </form>
      </div>
      
      <div class="section namespace">
        <h3><a href="index.html">Gtk</a></h3>
        <p>API Version: 4.0</p>
        
        <p>Library Version: 4.8.3</p>
        
      </div>
      
      
      <div class="section generator">
        <p>Generated by <a href="https://gitlab.gnome.org/GNOME/gi-docgen">gi-docgen</a> 2022.3</p>
      </div>
    </nav>

    <button id="btn-to-top" class="hidden"><span class="up-arrow"></span></button>

    
<section id="main" class="content">
  <section>
    <div class="docblock">
    <p>This chapter describes the <span class="caps">GTK</span> drawing model in detail. If you
are interested in the procedure which <span class="caps">GTK</span> follows to draw its
widgets and windows, you should read this chapter; this will be
useful to know if you decide to implement your own widgets. This
chapter will also clarify the reasons behind the ways certain
things are done in <span class="caps">GTK</span>.</p>
<h2 id="windows-and-events">Windows and events<a class="md-anchor" href="#windows-and-events" title="Permanent link"></a></h2>
<p>Applications that use a windowing system generally create
rectangular regions in the screen called <em>surfaces</em> (<span class="caps">GTK</span> is
following the Wayland terminology, other windowing systems
such as X11 may call these <em>windows</em>). Traditional windowing
systems do not automatically save the graphical content of
surfaces, and instead ask applications to provide new content
whenever it is needed. For example, if a window that is stacked
below other windows gets raised to the top, then the application
has to repaint it, so the previously obscured area can be shown.
When the windowing system asks an application to redraw a window,
it sends a <em>frame event</em> (<em>expose event</em> in X11 terminology)
for that&nbsp;window.</p>
<p>Each <span class="caps">GTK</span> toplevel window or dialog is associated with a
windowing system surface. Child widgets such as buttons or
entries don&#8217;t have their own surface; they use the surface
of their&nbsp;toplevel.</p>
<p>Generally, the drawing cycle begins when <span class="caps">GTK</span> receives a frame event
from the underlying windowing system: if the user drags a window
over another one, the windowing system will tell the underlying
surface that it needs to repaint itself. The drawing cycle can
also be initiated when a widget itself decides that it needs to
update its display. For example, when the user types a character
in an entry widget, the entry asks <span class="caps">GTK</span> to queue a redraw operation
for&nbsp;itself.</p>
<p>The windowing system generates frame events for surfaces. The <span class="caps">GDK</span>
interface to the windowing system translates such events into
emissions of the ::render signal on the affected surfaces. The <span class="caps">GTK</span>
toplevel window connects to that signal, and reacts&nbsp;appropriately.</p>
<p>The following sections describe how <span class="caps">GTK</span> decides which widgets
need to be repainted in response to such events, and how widgets
work internally in terms of the resources they use from the
windowing&nbsp;system.</p>
<h2 id="the-frame-clock">The frame clock<a class="md-anchor" href="#the-frame-clock" title="Permanent link"></a></h2>
<p>All <span class="caps">GTK</span> applications are mainloop-driven, which means that most
of the time the app is idle inside a loop that just waits for
something to happen and then calls out to the right place when
it does. On top of this <span class="caps">GTK</span> has a frame clock that gives a
“pulse” to the application. This clock beats at a steady rate,
which is tied to the framerate of the output (this is synced to
the monitor via the window manager/compositor). A typical
refresh rate is 60 frames per second, so a new “pulse” happens
roughly every 16&nbsp;milliseconds.</p>
<p>The clock has several&nbsp;phases:</p>
<ul>
<li>Events</li>
<li>Update</li>
<li>Layout</li>
<li>Paint</li>
</ul>
<p>The phases happens in this order and we will always run each
 phase through before going back to the&nbsp;start.</p>
<p>The Events phase is a stretch of time between each redraw where
<span class="caps">GTK</span> processes input events from the user and other events
(like e.g. network I/O). Some events, like mouse motion are
compressed so that only a single mouse motion event per clock
cycle needs to be&nbsp;handled.</p>
<p>Once the Events phase is over, external events are paused and
the redraw loop is run. First is the Update phase, where all
animations are run to calculate the new state based on the
estimated time the next frame will be visible (available via
the frame clock). This often involves geometry changes which
drive the next phase, Layout. If there are any changes in
widget size requirements the new layout is calculated for the
widget hierarchy (i.e. sizes and positions for all widgets are
determined). Then comes the Paint phase, where we redraw the
regions of the window that need&nbsp;redrawing.</p>
<p>If nothing requires the Update/Layout/Paint phases we will
stay in the Events phase forever, as we don’t want to redraw
if nothing changes. Each phase can request further processing
in the following phases (e.g. the Update phase will cause there
to be layout work, and layout changes cause&nbsp;repaints).</p>
<p>There are multiple ways to drive the clock, at the lowest level you
can request a particular phase with <code>gdk_frame_clock_request_phase()</code>
which will schedule a clock beat as needed so that it eventually
reaches the requested phase. However, in practice most things
happen at higher&nbsp;levels:</p>
<ul>
<li>If you are doing an animation, you can use
  <code>gtk_widget_add_tick_callback()</code> which will cause a regular
  beating of the clock with a callback in the Update phase
  until you stop the&nbsp;tick.</li>
<li>If some state changes that causes the size of your widget to
  change you call <code>gtk_widget_queue_resize()</code> which will request
  a Layout phase and mark your widget as needing&nbsp;relayout.</li>
<li>If some state changes so you need to redraw some area of
  your widget you use the normal <code>gtk_widget_queue_draw()</code>
  set of functions. These will request a Paint phase and
  mark the region as needing&nbsp;redraw.</li>
</ul>
<p>There are also a lot of implicit triggers of these from the
<span class="caps">CSS</span> layer (which does animations, resizes and repaints as&nbsp;needed).</p>
<h2 id="the-scene-graph">The scene graph<a class="md-anchor" href="#the-scene-graph" title="Permanent link"></a></h2>
<p>The first step in “drawing” a window is that <span class="caps">GTK</span> creates
<em>render nodes</em> for all the widgets in the window. The render
nodes are combined into a tree that you can think of as a
<em>scene graph</em> describing your window&nbsp;contents.</p>
<p>Render nodes belong to the <span class="caps">GSK</span> layer, and there are various kinds
of them, for the various kinds of drawing primitives you are likely
to need when translating widget content and <span class="caps">CSS</span> styling. Typical
examples are text nodes, gradient nodes, texture nodes or clip&nbsp;nodes.</p>
<p>In the past, all drawing in <span class="caps">GTK</span> happened via cairo. It is still possible
to use cairo for drawing your custom widget contents, by using a cairo
render&nbsp;node.</p>
<p>A <span class="caps">GSK</span> <em>renderer</em> takes these render nodes, transforms them into
rendering commands for the drawing <span class="caps">API</span> it targets, and arranges
for the resulting drawing to be associated with the right surface.
<span class="caps">GSK</span> has renderers for OpenGL, Vulkan and&nbsp;cairo.</p>
<h2 id="hierarchical-drawing">Hierarchical drawing<a class="md-anchor" href="#hierarchical-drawing" title="Permanent link"></a></h2>
<p>During the Paint phase <span class="caps">GTK</span> receives a single ::render signal on the
toplevel surface. The signal handler will create a snapshot object
(which is a helper for creating a scene graph) and call the
GtkWidget <code>snapshot()</code> vfunc, which will propagate down the widget
hierarchy. This lets each widget snapshot its content at the right
place and time, correctly handling things like partial transparencies
and overlapping&nbsp;widgets.</p>
<p>During the snapshotting of each widget, <span class="caps">GTK</span> automatically handles
the <span class="caps">CSS</span> rendering according to the <span class="caps">CSS</span> box model. It snapshots first
the background, then the border, then the widget content itself, and
finally the&nbsp;outline.</p>
<p>To avoid excessive work when generating scene graphs, <span class="caps">GTK</span> caches render
nodes. Each widget keeps a reference to its render node (which in turn,
will refer to the render nodes of children, and grandchildren, and so
on), and will reuse that node during the Paint phase. Invalidating a
widget (by calling gtk_widget_queue_draw()) discards the cached render
node, forcing the widget to regenerate it the next time it needs to
produce a&nbsp;snapshot.</p>
    </div>
  </section>
</section>


    
<div id="toc" class="toc">
  <nav aria-labelledby="toc-title">
    <p id="toc-title">Content</p>
    <ul class="toc-list">
      
        
        <li class="toc-list-item"><a href="#windows-and-events"><span class="link-text">Windows and events</span></a></li>
          
        
        <li class="toc-list-item"><a href="#the-frame-clock"><span class="link-text">The frame clock</span></a></li>
          
        
        <li class="toc-list-item"><a href="#the-scene-graph"><span class="link-text">The scene graph</span></a></li>
          
        
        <li class="toc-list-item"><a href="#hierarchical-drawing"><span class="link-text">Hierarchical drawing</span></a></li>
          
        
      
    </ul>
  </nav>
</div>


    <section id="search" class="content hidden"></section>

    <footer>
    
    </footer>
  </div>
</body>
</html>